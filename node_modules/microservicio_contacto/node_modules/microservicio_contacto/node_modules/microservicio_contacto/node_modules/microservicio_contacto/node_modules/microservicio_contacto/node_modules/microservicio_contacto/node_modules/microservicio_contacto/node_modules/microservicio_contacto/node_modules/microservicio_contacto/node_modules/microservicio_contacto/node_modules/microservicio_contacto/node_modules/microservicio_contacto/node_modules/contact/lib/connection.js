import { streamReadText } from 'stream-read-all'
import Transmission from 'contact-model/transmission'

/**
 * Adapter class de-coupling the Client from any transport-specific API, e.g. Node http2.
 * @emit "receive" {Transmission}
 */
class Connection extends EventTarget {
  http2session
  receiveStream

  constructor (http2session) {
    super()
    this.http2session = http2session
  }

  async listen () {
    /* incoming push stream */
    this.http2session.on('stream', async pushStream => {
      pushStream.on('push', async headers => {
        this.dispatchEvent(new CustomEvent('receive', { detail: Transmission.unsanitised(headers, pushStream) }))
      })
      pushStream.on('error', cause => {
        const err = new Error('Push stream error', { cause })
        console.error('PUSH STREAM ERROR', err)
      })
    })
    await this.setupReceiveStream()
  }

  async setupReceiveStream () {
    return new Promise((resolve, reject) => {
      this.receiveStream = this.http2session.request({ ':path': '/receive' }, { endStream: true })
      this.receiveStream.on('response', headers => {
        const status = headers[':status']
        if (status === 200) {
          resolve()
        } else {
          reject(new Error(`Receivestream setup failed: ${status}`))
        }
      })
      this.receiveStream.on('error', async cause => {
        if (cause.code === 'ETIMEDOUT') {
          const err = new Error('Receive stream timed out. Reconnecting.', { cause })
          console.error(err)
          await this.close()
          await this.setupReceiveStream()
        } else {
          const err = new Error('RECEIVE STREAM ERROR', { cause })
          console.error(err)
          await this.close()
          await this.setupReceiveStream()
        }
      })
      this.receiveStream.on('close', () => {
        // reject(new Error('Receive stream closed'))
      })
    })
  }

  /**
   * @fulfil { status: reponseStatus, command,  body: responseBody }
   */
  async tui (command, transmission) {
    return new Promise((resolve, reject) => {
      const reqHeaders = Object.assign({ ':path': '/tui' }, transmission?.headers, { command })
      const reqStream = this.http2session.request(reqHeaders, { endStream: false })
      reqStream.on('response', async headers => {
        let body = await streamReadText(reqStream)
        if (headers['content-type'] === 'application/json') {
          body = JSON.parse(body || '""')
        }
        resolve({ status: headers[':status'], command, body })
      })
      reqStream.on('error', reject)
      if (transmission) {
        transmission.readable.pipe(reqStream)
      } else {
        reqStream.end()
      }
    })
  }

  async ping () {
    return new Promise((resolve, reject) => {
      const reqStream = this.http2session.request({ ':path': '/ping' }, { endStream: true })
      reqStream.on('response', async headers => {
        const body = await streamReadText(reqStream)
        resolve({ status: headers[':status'], body })
      })
      reqStream.on('error', reject)
    })
  }

  async close () {
    return new Promise((resolve, reject) => {
      this.receiveStream?.on('close', resolve)
      this.receiveStream?.on('error', reject)
      this.receiveStream?.close()
    })
  }
}

export default Connection
