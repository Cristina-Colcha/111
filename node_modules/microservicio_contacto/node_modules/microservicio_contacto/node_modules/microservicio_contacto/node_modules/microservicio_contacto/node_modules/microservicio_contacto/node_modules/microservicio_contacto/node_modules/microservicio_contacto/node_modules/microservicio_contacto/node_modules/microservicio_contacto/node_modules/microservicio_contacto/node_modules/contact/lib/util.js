function pick (obj, keys) {
  obj = Object.assign({}, obj)
  return keys.reduce((newObj, key) => {
    if (obj && Object.hasOwn(obj, key)) {
      newObj[key] = obj[key]
    }
    return newObj
  }, {})
}

async function http2Fetch (client, path, reqBody, reqOptions) {
  reqOptions ||= { endStream: false }
  return new Promise((resolve, reject) => {
    let resBody = ''
    let resHeaders
    const reqHeaders = typeof path === 'string' ? { ':path': path } : path
    const req = client.request(reqHeaders, reqOptions)
    req.end(reqBody)
    req.setEncoding('utf-8')
    req.on('error', reject)
    req.on('response', (headers, flags) => {
      resHeaders = headers
      req.on('data', chunk => { resBody += chunk })
      req.on('end', () => {
        if (resHeaders[':status'] === 500) {
          const err = new Error('http2Fetch request failed')
          err.cause = resBody
          reject(err)
        } else {
          resolve({ resHeaders, resBody })
        }
      })
    })
  })
}

export { http2Fetch, pick }
